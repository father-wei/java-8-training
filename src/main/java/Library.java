import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.BinaryOperator;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Collector;
import java.util.stream.Stream;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Library {
    public boolean someLibraryMethod() {
        return true;
    }

    // custom collector

    public class HashMapCollector<String> implements Collector<String, HashMap<String, Integer>, HashMap<String, Integer>>{

        @Override
        public Supplier<HashMap<String, Integer>> supplier() {
            return () -> new HashMap<String, Integer>();
        }

        @Override
        public BiConsumer<HashMap<String, Integer>, String> accumulator() {
            return (acc , t) -> {
                if(acc.get(t) != null){
                    acc.put(t, acc.get(t) + 1);
                } else{
                    acc.put(t, 1);
                }
            };
        }

        @Override
        public BinaryOperator<HashMap<String, Integer>> combiner() {
            return (m1, m2) ->
                 (HashMap<String, Integer>) Stream.of(m1, m2)
                        .flatMap(m -> m.entrySet().stream())
                        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (x, y) -> x + y));

        }

        @Override
        public Function<HashMap<String, Integer>, HashMap<String, Integer>> finisher() {
            return x -> x;
        }

        @Override
        public Set<Characteristics> characteristics() {
            return EnumSet.of(Characteristics.UNORDERED);
        }
    }



    public List<String> ls = Arrays.asList("a", "b", "c" , "d", "a", "c");


    public void test(){
         Map<String, Integer> result = (HashMap<String, Integer>)ls.parallelStream().collect(new HashMapCollector());


         result.entrySet().stream().forEach(r -> System.out.println(r.getKey() + " " + r.getValue()));
    }
}
/*
    good code
  Merge too maps
  map3 = Stream.of(map1, map2).flatMap(m -> m.entrySet().stream())
       .collect(Collectors.toMap(Entry::getKey, Entry::getValue, Math::max))
*/

/*
    good code
  
  return Optional.ofNullable(config)
        .map(Configuration::getPayload)
        .map(c->c.get(key))
        .orElse("");
*/




